diff --git a/node_modules/@saltcorn/cli/node_modules/buffer-equal-constant-time/index.d.ts b/node_modules/@saltcorn/cli/node_modules/buffer-equal-constant-time/index.d.ts
new file mode 100644
index 0000000..4ce884e
--- /dev/null
+++ b/node_modules/@saltcorn/cli/node_modules/buffer-equal-constant-time/index.d.ts
@@ -0,0 +1,13 @@
+/** Constant-time Buffer comparison utility. */
+declare function bufferEqual(a: Buffer, b: Buffer): boolean;
+
+declare namespace bufferEqual {
+    /** Patch `Buffer.prototype.equal` to use the constant-time version. */
+    function install(): void;
+
+    /** Restore the original `Buffer.prototype.equal`. */
+    function restore(): void;
+}
+
+export = bufferEqual;
+
diff --git a/node_modules/@saltcorn/cli/node_modules/buffer-equal-constant-time/index.js b/node_modules/@saltcorn/cli/node_modules/buffer-equal-constant-time/index.js
index 5462c1f..b0f7636 100644
--- a/node_modules/@saltcorn/cli/node_modules/buffer-equal-constant-time/index.js
+++ b/node_modules/@saltcorn/cli/node_modules/buffer-equal-constant-time/index.js
@@ -1,41 +1,78 @@
-/*jshint node:true */
+/**
+ * @fileoverview Constant-time {@link Buffer} comparison utility compatible
+ * with Node.js v18 through v24.  The implementation prefers the built-in
+ * {@link crypto.timingSafeEqual} when available and falls back to a manual
+ * XOR loop executed in constant time.
+ *
+ * The public API intentionally matches `buffer-equal-constant-time@1.x`
+ * so that packages such as `jwa`/`jws` continue to work unchanged.
+ * @module buffer-equal-constant-time
+ */
+
 'use strict';
-var Buffer = require('buffer').Buffer; // browserify
-var SlowBuffer = require('buffer').SlowBuffer;
-
-module.exports = bufferEq;
-
-function bufferEq(a, b) {
-
-  // shortcutting on type is necessary for correctness
-  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
-    return false;
-  }
-
-  // buffer sizes should be well-known information, so despite this
-  // shortcutting, it doesn't leak any information about the *contents* of the
-  // buffers.
-  if (a.length !== b.length) {
-    return false;
-  }
-
-  var c = 0;
-  for (var i = 0; i < a.length; i++) {
-    /*jshint bitwise:false */
-    c |= a[i] ^ b[i]; // XOR
-  }
-  return c === 0;
+
+const crypto = require('crypto');
+
+/**
+ * Compare two {@link Buffer Buffers} in constant time.
+ *
+ * @param {!Buffer} a The first buffer.
+ * @param {!Buffer} b The second buffer.
+ * @return {boolean} `true` if the buffers are equal; `false` otherwise.
+ */
+function bufferEqual(a, b) {
+    // Guard against non-Buffer inputs (required for correctness).
+    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
+        return false;
+    }
+
+    // Length check is safe and avoids useless work if unequal.
+    if (a.length !== b.length) {
+        return false;
+    }
+
+    // Fast path: use the native constant-time helper when present.
+    /* c8 ignore next 3 */
+    if (typeof crypto.timingSafeEqual === 'function') {
+        return crypto.timingSafeEqual(a, b);
+    }
+
+    // Fallback: manual XOR diff executed for the full length.
+    let diff = 0;
+    for (let i = 0; i < a.length; ++i) {
+        diff |= a[i] ^ b[i];
+    }
+    return diff === 0;
 }
 
-bufferEq.install = function() {
-  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
-    return bufferEq(this, that);
-  };
+/**
+ * Monkey-patch {@link Buffer#equal} so legacy callers continue to work
+ * without code changes. Use sparingly; mutating built-ins is discouraged.
+ */
+bufferEqual.install = () => {
+    if (!bufferEqual.__origBufEqual) {
+        bufferEqual.__origBufEqual = Buffer.prototype.equal;
+    }
+
+    /* eslint-disable no-extend-native */
+    Buffer.prototype.equal = function equal(that) {
+        return bufferEqual(this, that);
+    };
+    /* eslint-enable no-extend-native */
 };
 
-var origBufEqual = Buffer.prototype.equal;
-var origSlowBufEqual = SlowBuffer.prototype.equal;
-bufferEq.restore = function() {
-  Buffer.prototype.equal = origBufEqual;
-  SlowBuffer.prototype.equal = origSlowBufEqual;
+/**
+ * Restore the original {@link Buffer#equal} implementation, if it was
+ * replaced by {@link bufferEqual.install}.
+ */
+bufferEqual.restore = () => {
+    /* eslint-disable no-extend-native */
+    if (bufferEqual.__origBufEqual) {
+        Buffer.prototype.equal = bufferEqual.__origBufEqual;
+        delete bufferEqual.__origBufEqual;
+    }
+    /* eslint-enable no-extend-native */
 };
+
+module.exports = bufferEqual;
+